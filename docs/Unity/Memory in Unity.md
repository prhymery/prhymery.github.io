---
layout: default
title: Memory in Unity
parent: Unity
nav_order: 1
---

# Memory in Unity
{: .no_toc }

---
Unity 에서 사용되는 메모리 영역에 대해 정리해보았습니다.

---
- TOC
{:toc}
---

## Managed memory

Managed heap 과 [Garbage Collector(GC)](/docs/Unity/Garbage Collector) 를 사용하여 자동으로 메모리를 할당하는 레이어입니다.

### Managed Heap

[스크립팅 백앤드(Mono or IL2CPP)](/docs/Unity/Mono vs IL2CPP/#scripting-backend) 의 GC 에 의해 자동으로 제어되는 메모리 영역입니다. Managed Heap 에 할당된 메모리를 GC Allocation 이라고 합니다.


<!-- // 잘 이해가 되지않아 다음에 추가하기 -->
<!-- ### The scripting stack -->
<!-- ### Native VM memory -->

// 영문과 비교해서 매끄러운 번역이 필요
관리되는 메모리 시스템은 VM을 사용하기 때문에 할당 레퍼런스를 자동으로 추적하여 수명을 관리하는 제어된 환경을 가집니다. 즉 다른 코드가 메모리에 액세스를 시도하는 동안 애플리케이션이 메모리를 너무 일찍 해제할 가능성이 적다는 것을 의미합니다. 또한 코드에서 메모리에 액세스할 수 없거나 사용하지 않는 메모리가 쌓여서 발생하는 메모리 누수에 대한 보호 장치가 된다는 의미이기도 합니다.

Unity에서 관리되는 메모리를 사용하는 것은 애플리케이션에서 메모리를 관리하는 가장 쉬운 방법입니다. 그러나 몇 가지 단점이 있습니다. 가비지 컬렉터는 사용하기 편리하지만 메모리 해제/할당 방식을 예측할 수 없기 때문에 가비지 컬렉터가 메모리 해제/할당을 중지해야 할 때 불안정한 성능 문제가 발생할 수 있습니다. 이러한 예측 불가능 문제를 해결하려면 C# 관리되지 않는 메모리 레이어를 사용하면 됩니다.

관리되는 메모리의 작동 방식에 대한 자세한 내용은 관리되는 메모리에 대한 문서를 참조하십시오.
//


#### 힙의 확장
{: .fs-4 }

메모리에 새로운 오브젝트를 할당하려고 할 때 새로운 오브젝트를 할당할 만큼 충분한 크기의 연속된 공간이 없다면 가비지 컬렉터 실행

실행 후에도 메모리 공간이 부족하면 힙을 2배로 확장

#### 문제점
{: .fs-4 }

한번 확장된 힙은 축소되지 않음? 좀더 큰 할당이 발생해도 힙을 다시 확장해야 하라 필요가 없더록 하기 위함

32비트 프로그램에서 관리되는 힙의 반복적인 확장 수축으로 프로그램이 사용가능한 메모리 주소 공간이 부족해지는 경우 운영체제가 해당 프로그램을 종료

??
32비트의 주소 공간은 4 GB 밖에 되지 않기 때문에 빈번하게 확장/축소가 일어나면결국 주소 공간이 부족해지고, 앱이 꺼지는 문제가 발생한다.
( => 최근 회사 게임에서 32비트 기기의 크래시가 빈번하게 발생하는 원인으로 보인다. ) 


## C# unmanaged memory

이 메모리 영억은 GC 로 메모리를 관리하지 않는 영역입니다. Unity 컬렉션 네임스페이스 및 패키지와 함께 사용할 수 있는 메모리 관리 레이어입니다.

C# 코드를 이용해 native memory 영역의 미세한 메모리 할당을 가능하게 합니다.
C# 관리되지 않는 메모리를 통해 C# 코드를 작성하는 편리함과 함께 네이티브 메모리 레이어에 액세스하여 메모리 할당을 미세 조정할 수 있습니다.

// 영문과 비교해서 매끄러운 번역이 필요
Unity 코어 API의 Unity.Collections 네임스페이스(NativeArray 포함)와 Unity 컬렉션 패키지의 데이터 구조를 사용하여 C# 관리되지 않는 메모리에 액세스할 수 있습니다. Unity의 C# 잡 시스템 또는 버스트를 사용하는 경우 C# 관리되지 않는 메모리를 사용해야 합니다. 이에 대한 자세한 내용은 잡 시스템과 버스트에 대한 문서를 참조하십시오.
//

## Native memory

Unity 엔진을 구동하는 데 사용하는 C++ 메모리를 말하며 자체 메모리 관리 시스템이 있습니다. 일반적으로 이 메모리 유형에 직접 액세스하거나 수정할 수 없습니다.

Unity는 프로젝트의 씬, 에셋, 그래픽스 API, 그래픽스 드라이버, 보조 시스템, 플러그인 버퍼를 저장하고 네이티브 메모리 내부에 할당합니다. 즉, Unity의 C# API를 통해 네이티브 메모리에 간접적으로 접근할 수 있습니다. 이로써 Unity의 네이티브 코어에 있는 네이티브 코드와 성능 코드의 이점을 잃지 않으면서 안전하고 쉬운 방법으로 애플리케이션의 데이터를 조작할 수 있습니다.

프로파일 마커를 통해 프로파일러를 사용할 때마다 이 메모리가 애플리케이션의 성능에 어떤 영향을 미치는지 확인할 수 있습니다.

// 각각의 소주제(##)를 GPT 에 검색해서 내용을 확인하고 검증하고 정리하는 작업이 필요함